(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('vue')) :
  typeof define === 'function' && define.amd ? define(['exports', 'vue'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.Grid = {}, global.Vue));
}(this, (function (exports, vue) { 'use strict';

  var directions = {
    vLeading: 'vertical-leading',
    vTrailing: 'vertical-trailing',
    hLeading: 'horizontal-leading',
    hTrailing: 'horizontal-trailing'
  };
  var script = {
    name: 'Grid',
    emits: ['rollover'],
    render: function render() {
      var _this = this;

      var cell = this.$slots.cell; // Grid cells renderer

      var getCells = function getCells() {
        var cells = []; // Build cells

        var _loop = function _loop(r, _p) {
          var _loop2 = function _loop2(c) {
            var rFromEnd = r - _this.rows - 1;
            var cFromEnd = c - _this.columns - 1;
            var item = null;

            if (_this.items && _this.items[_p - 1]) {
              item = _this.items[_p - 1];
            } // Add the cell for current row & column


            cells.push(vue.h('div', {
              class: ['vc-grid-cell', "vc-grid-cell-row-".concat(r), "vc-grid-cell-row-".concat(rFromEnd), "vc-grid-cell-col-".concat(c), "vc-grid-cell-col-".concat(cFromEnd)],
              style: {
                'grid-row': r,
                'grid-column': c
              },
              onKeydown: function onKeydown(e) {
                return _this.handleCellKeydown({
                  row: r,
                  column: c,
                  event: e
                });
              }
            }, [cell && cell({
              item: item,
              position: _p++,
              row: r,
              column: c
            })]));
          };

          for (var c = 1; c <= _this.columns; c++) {
            _loop2(c);
          }

          p = _p;
        };

        for (var r = 1, p = 1; r <= _this.rows; r++) {
          _loop(r, p);
        }

        return cells;
      };

      return vue.h('div', {
        class: 'vc-grid-container',
        style: this.containerStyle
      }, getCells());
    },
    props: {
      count: Number,
      rows: {
        type: Number,
        default: 1
      },
      columns: {
        type: Number,
        default: 1
      },
      gap: {
        type: String,
        default: '0px'
      },
      items: {
        type: Array,
        default: function _default() {
          return [];
        }
      },
      autofit: Boolean,
      columnWidth: {
        type: String,
        default: '1fr'
      },
      disableFocus: {
        type: Boolean,
        default: false
      }
    },
    computed: {
      containerStyle: function containerStyle() {
        return {
          gridTemplateColumns: this.gridTemplateColumns,
          gridGap: this.gap
        };
      },
      gridTemplateColumns: function gridTemplateColumns() {
        return "repeat(".concat(this.autofit ? 'auto-fit' : this.columns, ", ").concat(this.columnWidth, ")");
      }
    },
    methods: {
      handleCellKeydown: function handleCellKeydown(_ref) {
        var row = _ref.row,
            column = _ref.column,
            event = _ref.event;
        // Return if focus management is disabled
        if (this.disableFocus) return;
        var state = {
          row: row,
          column: column,
          alt: false,
          handled: false
        }; // Increment row/column based on key

        switch (event.key) {
          case 'ArrowUp':
            {
              state.row--;
              break;
            }

          case 'ArrowDown':
            {
              state.row++;
              break;
            }

          case 'ArrowLeft':
            {
              state.column--;
              break;
            }

          case 'ArrowRight':
            {
              state.column++;
              break;
            }

          case 'Home':
            {
              state.column = 1;
              break;
            }

          case 'End':
            {
              state.column = this.columns;
              break;
            }

          case 'PageUp':
            {
              state.alt = event.altKey;
              state.direction = directions.vLeading;
              break;
            }

          case 'PageDown':
            {
              state.alt = event.altKey;
              state.direction = directions.vTrailing;
              break;
            }

          default:
            {
              return;
            }
        } // Handle state for row rollovers


        if (state.row < 1) {
          state.direction = directions.vLeading;
          state.row = this.rows;
        } else if (state.row > this.rows) {
          state.direction = directions.vTrailing;
          state.row = 1;
        } // Handle state for column rollovers


        if (state.column < 1) {
          state.direction = directions.hLeading;
          state.column = this.columns;
        } else if (state.column > this.columns) {
          state.direction = directions.hTrailing;
          state.column = 1;
        } // Emit rollover event if direction was assigned


        if (state.direction) {
          this.$emit('rollover', state);
        } // Focused on cell for current state if event wasn't handled


        if (!state.handled) {
          // Get grid cell element
          var cellSelector = ".vc-grid-cell-row-".concat(state.row, ".vc-grid-cell-col-").concat(state.column);
          var cellEl = this.$el.querySelector(cellSelector);

          if (cellEl) {
            this.tryFocus(cellEl);
          }
        }

        event.stopPropagation();
        event.preventDefault();
      },
      tryFocus: function tryFocus() {
        var el = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.$el;
        this.$nextTick(function () {
          var selectors = ['.vc-grid-focus', 'button, [href], input, select, textarea, [tabindex="0"]', '[tabindex]:not([tabindex="undefined"])'];
          var focusableEl = selectors.map(function (s) {
            return el.querySelector(s);
          }).find(function (e) {
            return e;
          });

          if (focusableEl) {
            focusableEl.focus();
            return true;
          }

          return false;
        });
      }
    }
  };

  function styleInject(css, ref) {
    if ( ref === void 0 ) ref = {};
    var insertAt = ref.insertAt;

    if (!css || typeof document === 'undefined') { return; }

    var head = document.head || document.getElementsByTagName('head')[0];
    var style = document.createElement('style');
    style.type = 'text/css';

    if (insertAt === 'top') {
      if (head.firstChild) {
        head.insertBefore(style, head.firstChild);
      } else {
        head.appendChild(style);
      }
    } else {
      head.appendChild(style);
    }

    if (style.styleSheet) {
      style.styleSheet.cssText = css;
    } else {
      style.appendChild(document.createTextNode(css));
    }
  }

  var css_248z = ".vc-grid-container {\r\n  position: relative;\r\n  -ms-flex-negative: 1;\r\n      -webkit-flex-shrink: 1;\r\n          flex-shrink: 1;\r\n  display: grid;\r\n  overflow: auto;\r\n  -webkit-overflow-scrolling: touch;\r\n}\r\n.vc-grid-cell {\r\n  display: -webkit-flex;\r\n  display: -ms-flexbox;\r\n  display: flex;\r\n  -webkit-justify-content: center;\r\n      -ms-flex-pack: center;\r\n          justify-content: center;\r\n  -webkit-align-items: center;\r\n      -ms-flex-align: center;\r\n          align-items: center;\r\n}\n";
  styleInject(css_248z);

  exports.default = script;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
